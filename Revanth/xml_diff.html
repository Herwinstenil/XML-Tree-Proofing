<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>XML Gibberish Detector (Client-Only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Your requested CDN (if it exposes isGibberish or window.GibberishDetector) -->
  <script src="https://cdn.jsdelivr.net/npm/gibberish-detector@1.0.0/index.min.js"></script>
  <style>
    body{font-family:system-ui,Arial,sans-serif;max-width:1100px;margin:24px auto;padding:0 16px}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .card{flex:1 1 480px;border:1px solid #ddd;border-radius:12px;padding:14px}
    pre{white-space:pre-wrap;word-wrap:break-word;max-height:220px;overflow:auto;background:#fafafa;padding:10px;border-radius:8px}
    .ok{color:#0a7a0a} .bad{color:#b00020} .tag{background:#eef;border-radius:6px;padding:2px 6px;margin-right:6px}
    .pill{display:inline-block;font-size:12px;background:#ffe9e9;border:1px solid #ffb3b3;margin:2px 4px;padding:2px 6px;border-radius:999px}
    button{padding:10px 14px;border-radius:10px;border:1px solid #ccc;background:#111;color:#fff;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .small{font-size:12px;color:#666}
  </style>
</head>
<body>
  <h2>XML Gibberish Detector â€” Frontend Only ðŸ§ âœ¨</h2>

  <div class="row">
    <div class="card">
      <h3>1) Upload files ðŸ“‚</h3>
      <label>Original.xml: <input id="orig" type="file" accept=".xml,.html,.xhtml,.txt"></label><br/><br/>
      <label>Incorrect.xml: <input id="inc" type="file" accept=".xml,.html,.xhtml,.txt"></label><br/><br/>
      <button id="run" disabled>Find Gibberish âš¡</button>
      <div class="small">Tip: We whitelist words seen in Original to avoid false alarms (codes/names). âœ…</div>
    </div>

    <div class="card">
      <h3>2) Quick preview ðŸ‘€</h3>
      <div class="row">
        <div class="card" style="flex:1">
          <div class="tag">original.xml</div>
          <pre id="prevOrig"></pre>
        </div>
        <div class="card" style="flex:1">
          <div class="tag">incorrect.xml</div>
          <pre id="prevInc"></pre>
        </div>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>3) Result ðŸ§¾</h3>
    <div id="summary" class="small">No run yet.</div>
    <div id="out"></div>
  </div>

  <script>
    // --- Helpers ---
    const $ = (id) => document.getElementById(id);
    const RX_WORD = /\b[A-Za-z']+\b/g;

    function tokenize(t){ return (t.match(RX_WORD) || []).map(w => w.trim()).filter(Boolean); }

    // Fallback heuristic if CDN doesn't expose a function
    function fallbackIsGibberish(word){
      const w = word.toLowerCase();
      if (w.length <= 1 || /^\d+$/.test(w)) return false;
      if (/(.)\1{3,}/.test(w)) return true;                   // aaaa, !!!!, 1111
      if (/[bcdfghjklmnpqrstvwxyz]{5,}/i.test(w)) return true; // long consonant runs
      if (/[aeiou]/.test(w) === false && w.length >= 4) return true; // no vowels
      return false;
    }

    function getDetector(){
      // Try typical globals/exports from that CDN, else fallback
      if (typeof isGibberish === "function") return isGibberish;
      if (window.GibberishDetector && typeof window.GibberishDetector.isGibberish === "function") {
        return window.GibberishDetector.isGibberish.bind(window.GibberishDetector);
      }
      return fallbackIsGibberish;
    }

    function readFileText(file){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(String(fr.result || ""));
        fr.onerror = reject;
        fr.readAsText(file);
      });
    }

    function parseXmlToDoc(xmlText){
      const parser = new DOMParser();
      // Treat as XML/HTML; if XML fails, try HTML
      let doc = parser.parseFromString(xmlText, "application/xml");
      // Check parsererror
      if (doc.getElementsByTagName("parsererror").length){
        doc = parser.parseFromString(xmlText, "text/html");
      }
      return doc;
    }

    function* iterateTextNodes(root){
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
        acceptNode: (node) => node.nodeValue.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT
      });
      let n;
      while ((n = walker.nextNode())) yield n;
    }

    function nodePath(node){
      // Build a simple CSS-like path for display
      let el = node.nodeType === 3 ? node.parentElement : node;
      const parts = [];
      while (el && el.nodeType === 1 && parts.length < 10){
        const tag = el.tagName ? el.tagName.toLowerCase() : "node";
        const id  = el.getAttribute?.("id");
        const gid = el.getAttribute?.("genid") || el.getAttribute?.("xwebid");
        let label = tag;
        if (gid) label += `[genid="${gid}"]`;
        else if (id) label += `#${id}`;
        parts.unshift(label);
        el = el.parentElement;
      }
      return parts.join(" > ");
    }

    function buildWhitelistFromOriginal(origDoc){
      const set = new Set();
      for (const tn of iterateTextNodes(origDoc)){
        for (const w of tokenize(tn.nodeValue)) set.add(w.toLowerCase());
      }
      return set;
    }

    function compareForGibberish(origDoc, incDoc, detector){
      const whitelist = buildWhitelistFromOriginal(origDoc);
      const results = [];
      let total = 0, pos = 0;

      for (const tn of iterateTextNodes(incDoc)){
        pos += 1;
        const words = tokenize(tn.nodeValue);
        const bad = [];
        for (const w of words){
          if (whitelist.has(w.toLowerCase())) continue; // seen in original
          try {
            if (detector(w)) bad.push(w);
          } catch {
            if (fallbackIsGibberish(w)) bad.push(w);
          }
        }
        if (bad.length){
          total += bad.length;
          results.push({ position: pos, path: nodePath(tn), words: [...new Set(bad)] });
        }
      }
      return { count: total, nodes: results };
    }

    // --- UI wiring ---
    let origText = "", incText = "";

    function updateButton(){
      $("run").disabled = !(origText && incText);
    }

    $("orig").addEventListener("change", async (e) => {
      const f = e.target.files?.[0];
      origText = f ? await readFileText(f) : "";
      $("prevOrig").textContent = origText.slice(0, 4000);
      updateButton();
    });

    $("inc").addEventListener("change", async (e) => {
      const f = e.target.files?.[0];
      incText = f ? await readFileText(f) : "";
      $("prevInc").textContent = incText.slice(0, 4000);
      updateButton();
    });

    $("run").addEventListener("click", () => {
      const detector = getDetector();
      const origDoc = parseXmlToDoc(origText);
      const incDoc  = parseXmlToDoc(incText);

      const t0 = performance.now();
      const out = compareForGibberish(origDoc, incDoc, detector);
      const t1 = performance.now();

      $("summary").innerHTML = `
        <span class="${out.count ? 'bad' : 'ok'}">
          ${out.count ? 'Found ' + out.count + ' gibberish words' : 'No gibberish found'}
        </span> â€¢ Took ${(t1 - t0).toFixed(1)} ms
      `;

      const box = $("out");
      box.innerHTML = "";
      if (!out.nodes.length){
        box.innerHTML = "<div class='ok'>All good âœ…</div>";
        return;
      }
      for (const n of out.nodes){
        const div = document.createElement("div");
        div.className = "card";
        div.innerHTML = `
          <div><span class="tag">pos ${n.position}</span> <code>${n.path}</code></div>
          <div style="margin-top:6px">${n.words.map(w => `<span class="pill">${w}</span>`).join(" ")}</div>
        `;
        box.appendChild(div);
      }
    });
  </script>
</body>
</html>
